<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bolson</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">2.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stream.html"><strong aria-hidden="true">2.1.</strong> Stream mode</a></li><li class="chapter-item expanded "><a href="microbench.html"><strong aria-hidden="true">2.2.</strong> Micro-benchmarks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="microbench-convert.html"><strong aria-hidden="true">2.2.1.</strong> Convert</a></li><li class="chapter-item expanded "><a href="microbench-pulsar.html"><strong aria-hidden="true">2.2.2.</strong> Pulsar</a></li></ol></li><li class="chapter-item expanded "><a href="fpga.html"><strong aria-hidden="true">2.3.</strong> FPGA implementations</a></li></ol></li><li class="chapter-item expanded "><a href="design-overview.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="design-hardware.html"><strong aria-hidden="true">3.2.</strong> Hardware accelerated parsing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-battery.html"><strong aria-hidden="true">3.2.1.</strong> Battery status</a></li><li class="chapter-item expanded "><a href="design-trip.html"><strong aria-hidden="true">3.2.2.</strong> Trip report</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Bolson</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Bolson is a tool that parses JSONs, converts them to records in an Apache Arrow
formatted RecordBatch, serializes the batch to an Arrow IPC message, and 
publishes the message to a Pulsar topic.</p>
<p><img src="introduction_overview_0.generated.svg" alt="" title="Overview" /></p>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>This chapter describes how to use Bolson.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To use Bolson, you need the following:</p>
<ul>
<li>A source of JSON data that acts as a TCP server. Bolson operates as long as the connection is alive.</li>
<li>An <a href="https://pulsar.apache.org">Apache Pulsar</a> broker.</li>
<li>An <a href="https://arrow.apache.org">Apache Arrow</a> <a href="usage.html#arrow-schema">Schema</a>
<ul>
<li>Unless fixed schema parsing implementations are used, such as specific FPGA implementations.</li>
</ul>
</li>
</ul>
<h3 id="arrow-schema"><a class="header" href="#arrow-schema">Arrow Schema</a></h3>
<p>For Bolson to read Arrow Schemas, they need to be serialized to a file using
Arrow's built-in schema serialization facility.</p>
<p>An example of how to define and serialize a schema in Python:</p>
<pre><code class="language-python">import pyarrow

schema = pyarrow.schema([pyarrow.field(&quot;field&quot;, pyarrow.uint64())])
pyarrow.output_stream(&quot;example.as&quot;).write(schema.serialize())
</code></pre>
<h3 id="json-data-source"><a class="header" href="#json-data-source">JSON data source</a></h3>
<p>If you do not have a JSON data source that can act as a TCP server, it is
possible to generate random JSON data using a companion project of Bolson named <a href="https://github.com/teratide/illex">Illex</a>.</p>
<p>Illex is used throughout this example.</p>
<p>The requirements for a JSON data source acting as a TCP are simple. When Bolson
connects, the source can start sending data, without any additional protocol,
with the exception that each JSON object must be terminated by the newline
character <code>'\n'</code>.</p>
<h3 id="pulsar-broker"><a class="header" href="#pulsar-broker">Pulsar broker</a></h3>
<p>If you do not have a Pulsar broker, it can easily be spawned locally using
<a href="https://docker.com">Docker</a>:</p>
<pre><code class="language-bash">docker run -it --rm -p 6650:6650 -p 8080:8080 apachepulsar/pulsar bin/pulsar standalone
</code></pre>
<h2 id="subcommands"><a class="header" href="#subcommands">Subcommands</a></h2>
<p>Bolson knows two subcommands, <code>stream</code> and <code>bench</code>.</p>
<ul>
<li><strong>Stream</strong>: Convert JSONs and publish them to Pulsar in a streaming fashion.</li>
<li><strong>Bench</strong>: Run micro-benchmarks of specific components of Bolson.</li>
</ul>
<h3 id="stream"><a class="header" href="#stream">Stream</a></h3>
<pre><code>Produce Pulsar messages from a JSON TCP stream.
Usage: bolson stream [OPTIONS] [input]

Positionals:
  input TEXT:FILE                                 Serialized Arrow schema file for records to convert to.

Options:
  -h,--help                                       Print this help message and exit
  --latency TEXT                                  Enable batch latency measurements and write to supplied file.
  --metrics TEXT                                  Write metrics to supplied file.
  --max-rows UINT=1024                            Maximum number of rows per RecordBatch.
  --max-ipc UINT=5232640                          Maximum size of IPC messages in bytes.
  --threads UINT=1                                Number of threads to use for conversion.
  -p,--parser ENUM:value in {arrow-&gt;0,opae-battery-&gt;1,opae-trip-&gt;2} OR {0,1,2}=0
                                                  Parser implementation. OPAE parsers have fixed schema and ignore schema supplied to -i.
  -i,--input TEXT:FILE                            Serialized Arrow schema file for records to convert to.
  --arrow-buf-cap UINT=16777216                   Arrow input buffer capacity.
  --arrow-seq-col=0                               Arrow parser, retain ordering information by adding a sequence number column.
  --battery-afu-id TEXT                           OPAE &quot;battery status&quot; AFU ID. If not supplied, it is derived from number of parser instances.
  --battery-num-parsers UINT=8                    OPAE &quot;battery status&quot; number of parser instances.
  --battery-seq-col=0                             OPAE &quot;battery status&quot; parser, retain ordering information by adding a sequence number column.
  --trip-afu-id TEXT                              OPAE &quot;trip report&quot; AFU ID. If not supplied, it is derived from number of parser instances.
  --trip-num-parsers UINT=4                       OPAE &quot;trip report&quot; number of parser instances.
  -u,--pulsar-url TEXT=pulsar://localhost:6650/   Pulsar broker service URL.
  -t,--pulsar-topic TEXT=non-persistent://public/default/bolson
                                                  Pulsar topic.
  --pulsar-max-msg-size UINT=5232640
  --pulsar-producers UINT=1                       Number of concurrent Pulsar producers.
  --pulsar-batch                                  Enable batching Pulsar producer(s).
  --pulsar-batch-max-messages UINT=1000           Pulsar batching max. messages.
  --pulsar-batch-max-bytes UINT=131072            Pulsar batching max. bytes.
  --pulsar-batch-max-delay UINT=10                Pulsar batching max. delay (ms).
  --host TEXT=localhost                           JSON source TCP server hostname.
  --port UINT=10197                               JSON source TCP server port.

</code></pre>
<h3 id="bench"><a class="header" href="#bench">Bench</a></h3>
<pre><code>Run micro-benchmarks on isolated pipeline stages.
Usage: bolson bench [OPTIONS] SUBCOMMAND

Options:
  -h,--help                                       Print this help message and exit

Subcommands:
  client                                          Run TCP client interface microbenchmark.
  convert                                         Run JSON to Arrow IPC convert microbenchmark.
  queue                                           Run queue microbenchmark.
  pulsar                                          Run Pulsar publishing microbenchmark.

</code></pre>
<h1 id="stream-mode"><a class="header" href="#stream-mode">Stream mode</a></h1>
<h1 id="micro-benchmarks"><a class="header" href="#micro-benchmarks">Micro-benchmarks</a></h1>
<h1 id="parsing"><a class="header" href="#parsing">Parsing</a></h1>
<h1 id="pulsar-producer"><a class="header" href="#pulsar-producer">Pulsar producer</a></h1>
<h1 id="fpga-accelerated-parsing"><a class="header" href="#fpga-accelerated-parsing">FPGA accelerated parsing</a></h1>
<p>By default, Bolson parses and converts JSONs using Arrow's built-in JSON parser.
Bolson can also run with FPGA-accelerated parsing enabled for specific, hard
coded schemas.</p>
<h2 id="fletcherintel-opae"><a class="header" href="#fletcherintel-opae">Fletcher/Intel OPAE</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>A system set up according to the setup instructions for <a href="https://teratide.github.io/fletcher-opae">Fletcher OPAE</a>.</li>
<li>The correct bitstream for a specific Arrow schema &amp; parser implementation.</li>
</ul>
<h3 id="flash-the-bitstream"><a class="header" href="#flash-the-bitstream">Flash the bitstream</a></h3>
<p>Make sure to first flash the bitstream. From the <a href="https://teratide.github.io/fletcher-opae">Fletcher OPAE</a> guide:</p>
<p>Start the FPGA development environment container for the Intel Acceleration
Stack (IAS).</p>
<pre><code class="language-bash">cd path/to/bitstream
docker run -it --rm --privileged -v `pwd`:/src:ro ias:1.2.1
</code></pre>
<p>From the IAS container, program the FPGA with the bitstream and exit the
container:</p>
<pre><code class="language-bash">fpgaconf bitstream.gbs
exit
</code></pre>
<h3 id="enable-huge-pages"><a class="header" href="#enable-huge-pages">Enable huge pages</a></h3>
<p>The current implementation of Fletcher OPAE based accelerators requires huge
pages to be enabled.</p>
<p>On a CentOS system, they can be enabled by root users as follows:</p>
<pre><code class="language-bash">sudo su
echo 32 | tee /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages
exit
</code></pre>
<h3 id="run-bolson-with-fpga-accelerated-parser-implementation"><a class="header" href="#run-bolson-with-fpga-accelerated-parser-implementation">Run Bolson with FPGA-accelerated parser implementation</a></h3>
<p>Run Bolson with the <code>-p</code> or <code>--parser</code> option followed by the name of the
implementation of to select which FPGA-accelerated parser implementation to use
for the respective subcommand (<code>stream</code> or <code>bench convert</code>).</p>
<p>To see which implementations are available, run Bolson
with <code>&lt;subcommand&gt; --help</code>.</p>
<p>Example:</p>
<pre><code class="language-bash">bolson bench convert path/to/schema.as -p opae-battery
</code></pre>
<h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This chapter describes the high-level architecture of Bolson.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Bolson consists of three major components:</p>
<ul>
<li><strong>Client</strong>
<ul>
<li>TCP client, connects to a data source acting as a TCP server. Places
received TCP packets in buffers for conversion.</li>
</ul>
</li>
<li><strong>Converter</strong>
<ul>
<li>Parses JSON objects, converts them to Arrow RecordBatches, and serializes
the RecordBatches as Arrow IPC messages. These IPC messages are pushed
into a queue.</li>
</ul>
</li>
<li><strong>Publisher</strong>
<ul>
<li>Takes IPC messages from the queue and publishes them to a Pulsar topic.</li>
</ul>
</li>
</ul>
<p>An overview of the architecture of Bolson is shown below:</p>
<p><img src="design_overview_0.generated.svg" alt="" title="Overview" /></p>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>The Client connects to a server through a TCP socket. As long as the connection
exists, Bolson continues to operate. Upon the arrival of a TPDU, it's payload is
stored in one of the B TCP buffers, whichever next buffer is not locked and
empty in a round-robin fashion. If no buffers are available, no TPDUs will be
received until a buffer becomes available.</p>
<p>Whenever a buffer is filled with data, before unlocking the buffer for
conversion, the client reverse scans the buffer for the newline character that
must proceed every JSON object. Any leftover bytes and characters in the buffer
will be carried over to the next buffer, such that a buffer always contains a
discrete number of JSONs. This assumes that the JSON data source will always
place a newline character <code>'\n'</code> behind every JSON.</p>
<h3 id="converter"><a class="header" href="#converter">Converter</a></h3>
<p>The converter takes the contents of a TCP buffer, and parses the JSONs contained
within. JSONs are expected to be separated by whitespace, i.e. at the end of
each JSON, there must be a whitespace character <code>'\n'</code>. The JSON data is
converted to an Arrow RecordBatch (simply called batch from here on). This batch
is serialized as an Arrow IPC message, and pushed onto a concurrent queue.</p>
<p>Converters may be implemented as developers see fit, but the baseline software
converter is a concurrent converter that can use multiple <strong>C</strong> threads to
convert the data contained in the TCP buffers.</p>
<p>An overview of a converter thread is as follows:</p>
<p><img src="design_1.generated.svg" alt="" /></p>
<ul>
<li><strong>Parse</strong>
<ul>
<li>To parse JSONs, Bolson uses the <a href="https://arrow.apache.org/docs/cpp/json.html">Apache Arrow JSON parsing</a> functionality,
which, at the time of writing, uses <a href="https://rapidjson.org">RapidJSON</a> under the hood.</li>
<li>Bolson also currently knows two FPGA-accelerated parser implementations
that are described in following sections.</li>
</ul>
</li>
<li><strong>Resize</strong>
<ul>
<li>Because the size of a serialized batch can exceed the maximum size of a
Pulsar message, it is necessary for converters to resize batches if they
exceed the user-defined limit of a number of rows or a number of bytes.
This is a zero-copy operation.</li>
</ul>
</li>
<li><strong>Serialize</strong>
<ul>
<li>This step serialized the resized batches to Arrow IPC messages and pushes
the IPC messages into the concurrent queue.</li>
</ul>
</li>
</ul>
<h4 id="converter-threads"><a class="header" href="#converter-threads">Converter threads</a></h4>
<p>The converter setup discussed so far converts the JSONs in one buffer to one
Arrow RecordBatch, which is then potentially split up over K messages. The
internal thread that manages this type of conversion is called the one-to-one
converter thread.</p>
<p>Another setup is possible, where a converter thread can take data from all input
buffers at the same time, and convert that to one RecordBatch before resizing.
This thread is internally called the All-To-One converter thread and is spawned
when a parser implementation provides multiple input buffers but notifies the
converter that it should only spawn one thread.</p>
<p>The all-to-one approach is currently only used for an FPGA implementation where
the circuitry from the hardware parsers to the host memory is relatively large
in terms of area, but provides much higher throughput than a single parser can
deliver, and it is therefore shared with multiple other hardware parsers. This
way, the data for each parser working on each input buffer ends up in the same
RecordBatch, hence it becomes an &quot;all-to-one&quot; parser implementation requiring an
all-to-one converter thread.</p>
<h3 id="publisher"><a class="header" href="#publisher">Publisher</a></h3>
<p>The publisher component pops Arrow IPC messages from the concurrent queue and
publishes these Arrow IPC messages to a Pulsar topic. The implementation uses
the <a href="https://pulsar.apache.org/docs/en/client-libraries-cpp">Pulsar C++ client library</a>.</p>
<p>To increase the throughput, it is possible to spawn <strong>P</strong> Pulsar producer
threads to publish IPC messages from the queue concurrently.</p>
<p>If IPC messages are small, but many of them arrive every second, it is possible
to reduce the overhead having the Pulsar producers apply batching. Note well
that this always comes at the cost of increased latency.</p>
<h3 id="detailed-documentation--doxygen"><a class="header" href="#detailed-documentation--doxygen">Detailed documentation / Doxygen</a></h3>
<p>Detailed documentation of the sources can be generated by running Doxygen from
the root of the repository. The output can then be accessed by
opening: <code>doc/html/index.html</code></p>
<h1 id="design-1"><a class="header" href="#design-1">Design</a></h1>
<p>This chapter describes the high-level architecture of Bolson.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Bolson consists of three major components:</p>
<ul>
<li><strong>Client</strong>
<ul>
<li>TCP client, connects to a data source acting as a TCP server. Places
received TCP packets in buffers for conversion.</li>
</ul>
</li>
<li><strong>Converter</strong>
<ul>
<li>Parses JSON objects, converts them to Arrow RecordBatches, and serializes
the RecordBatches as Arrow IPC messages. These IPC messages are pushed
into a queue.</li>
</ul>
</li>
<li><strong>Publisher</strong>
<ul>
<li>Takes IPC messages from the queue and publishes them to a Pulsar topic.</li>
</ul>
</li>
</ul>
<p>An overview of the architecture of Bolson is shown below:</p>
<p><img src="overview_overview_0.generated.svg" alt="" title="Overview" /></p>
<h3 id="client-1"><a class="header" href="#client-1">Client</a></h3>
<p>The Client connects to a server through a TCP socket. As long as the connection
exists, Bolson continues to operate. Upon the arrival of a TPDU, it's payload is
stored in one of the B TCP buffers, whichever next buffer is not locked and
empty in a round-robin fashion. If no buffers are available, no TPDUs will be
received until a buffer becomes available.</p>
<p>Whenever a buffer is filled with data, before unlocking the buffer for
conversion, the client reverse scans the buffer for the newline character that
must proceed every JSON object. Any leftover bytes and characters in the buffer
will be carried over to the next buffer, such that a buffer always contains a
discrete number of JSONs. This assumes that the JSON data source will always
place a newline character <code>'\n'</code> behind every JSON.</p>
<h3 id="converter-1"><a class="header" href="#converter-1">Converter</a></h3>
<p>The converter takes the contents of a TCP buffer, and parses the JSONs contained
within. JSONs are expected to be separated by whitespace, i.e. at the end of
each JSON, there must be a whitespace character <code>'\n'</code>. The JSON data is
converted to an Arrow RecordBatch (simply called batch from here on). This batch
is serialized as an Arrow IPC message, and pushed onto a concurrent queue.</p>
<p>Converters may be implemented as developers see fit, but the baseline software
converter is a concurrent converter that can use multiple <strong>C</strong> threads to
convert the data contained in the TCP buffers.</p>
<p>An overview of a converter thread is as follows:</p>
<p><img src="overview_1.generated.svg" alt="" /></p>
<ul>
<li><strong>Parse</strong>
<ul>
<li>To parse JSONs, Bolson uses the <a href="https://arrow.apache.org/docs/cpp/json.html">Apache Arrow JSON parsing</a> functionality,
which, at the time of writing, uses <a href="https://rapidjson.org">RapidJSON</a> under the hood.</li>
<li>Bolson also currently knows two FPGA-accelerated parser implementations
that are described in following sections.</li>
</ul>
</li>
<li><strong>Resize</strong>
<ul>
<li>Because the size of a serialized batch can exceed the maximum size of a
Pulsar message, it is necessary for converters to resize batches if they
exceed the user-defined limit of a number of rows or a number of bytes.
This is a zero-copy operation.</li>
</ul>
</li>
<li><strong>Serialize</strong>
<ul>
<li>This step serialized the resized batches to Arrow IPC messages and pushes
the IPC messages into the concurrent queue.</li>
</ul>
</li>
</ul>
<h4 id="converter-threads-1"><a class="header" href="#converter-threads-1">Converter threads</a></h4>
<p>The converter setup discussed so far converts the JSONs in one buffer to one
Arrow RecordBatch, which is then potentially split up over K messages. The
internal thread that manages this type of conversion is called the one-to-one
converter thread.</p>
<p>Another setup is possible, where a converter thread can take data from all input
buffers at the same time, and convert that to one RecordBatch before resizing.
This thread is internally called the All-To-One converter thread and is spawned
when a parser implementation provides multiple input buffers but notifies the
converter that it should only spawn one thread.</p>
<p>The all-to-one approach is currently only used for an FPGA implementation where
the circuitry from the hardware parsers to the host memory is relatively large
in terms of area, but provides much higher throughput than a single parser can
deliver, and it is therefore shared with multiple other hardware parsers. This
way, the data for each parser working on each input buffer ends up in the same
RecordBatch, hence it becomes an &quot;all-to-one&quot; parser implementation requiring an
all-to-one converter thread.</p>
<h3 id="publisher-1"><a class="header" href="#publisher-1">Publisher</a></h3>
<p>The publisher component pops Arrow IPC messages from the concurrent queue and
publishes these Arrow IPC messages to a Pulsar topic. The implementation uses
the <a href="https://pulsar.apache.org/docs/en/client-libraries-cpp">Pulsar C++ client library</a>.</p>
<p>To increase the throughput, it is possible to spawn <strong>P</strong> Pulsar producer
threads to publish IPC messages from the queue concurrently.</p>
<p>If IPC messages are small, but many of them arrive every second, it is possible
to reduce the overhead having the Pulsar producers apply batching. Note well
that this always comes at the cost of increased latency.</p>
<h3 id="detailed-documentation--doxygen-1"><a class="header" href="#detailed-documentation--doxygen-1">Detailed documentation / Doxygen</a></h3>
<p>Detailed documentation of the sources can be generated by running Doxygen from
the root of the repository. The output can then be accessed by
opening: <code>doc/html/index.html</code></p>
<h2 id="hardware-accelerated-parsing"><a class="header" href="#hardware-accelerated-parsing">Hardware accelerated parsing</a></h2>
<h1 id="battery-status"><a class="header" href="#battery-status">Battery status</a></h1>
<h1 id="trip-report"><a class="header" href="#trip-report">Trip report</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
